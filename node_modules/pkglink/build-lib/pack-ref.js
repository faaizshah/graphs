"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.reduce");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prune = prune;
exports.verifyDMP = verifyDMP;
exports.buildPackRef = buildPackRef;
exports.verifyPackRef = verifyPackRef;
exports.determinePackLinkSrcDst = determinePackLinkSrcDst;

var _fsExtraPromise = _interopRequireDefault(require("fs-extra-promise"));

var _path = _interopRequireDefault(require("path"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _ramda = _interopRequireDefault(require("ramda"));

var _rxjs = require("rxjs");

var _format = require("./util/format");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function prune(config, dnvPR) {
  // return obs of new dnvPR object
  return _rxjs.Observable.from(_ramda["default"].toPairs(dnvPR) // [dnv, arrPackRef]
  ).mergeMap(function (dnv_PR) {
    return verifyDMP(dnv_PR, config);
  }).reduce(function (acc, dnv_PR) {
    return _ramda["default"].append(dnv_PR, acc);
  }, []).map(function (flatDMR) {
    return _ramda["default"].fromPairs(flatDMR);
  });
}

function verifyDMP(_ref, config) {
  var _ref2 = _slicedToArray(_ref, 2),
      dnv = _ref2[0],
      arrPackRef = _ref2[1];

  // return obs of valid dnv_PR
  var concurrentOps = config.concurrentOps;
  return _rxjs.Observable.from(arrPackRef) // obs of packRefs
  // returns obs of valid packRef
  .mergeMap(function (packRef) {
    return verifyPackRef(dnv, packRef, false);
  }, concurrentOps).reduce(function (acc, packRef) {
    return _ramda["default"].append(packRef, acc);
  }, []).filter(function (arrRefEI) {
    return arrRefEI.length;
  }).map(function (arrRefEI) {
    return [dnv, arrRefEI];
  }); // dnv_PR
}

function buildPackRef(modFullPath, packageJsonInode, packageJsonMTimeEpoch) {
  return [modFullPath, packageJsonInode, packageJsonMTimeEpoch];
}

function verifyPackRef(dnv, packRef) {
  var returnEI = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // return obs of valid packRef
  var modDir = packRef[0];
  var packInode = packRef[1];
  var packMTimeEpoch = packRef[2];

  var packPath = _path["default"].join(modDir, 'package.json');

  var packStat;
  return _rxjs.Observable.from(_fsExtraPromise["default"].statAsync(packPath).then(function (stat) {
    // eslint-disable-line consistent-return
    if (stat && stat.ino === packInode && stat.mtime.getTime() === packMTimeEpoch) {
      packStat = stat; // save for later use

      return _fsExtraPromise["default"].readJsonAsync(packPath, {
        "throws": false
      });
    }

    return undefined;
  }) // if json and matches, return packRef or EI
  .then(function (json) {
    // eslint-disable-line consistent-return
    if (json) {
      var devNameVer = (0, _format.formatDevNameVersion)(packStat.dev, json.name, json.version);

      if (devNameVer === dnv) {
        return returnEI ? {
          // masterEI
          stat: packStat,
          fullParentDir: modDir
        } : packRef;
      }
    }

    return undefined;
  })["catch"](function (err) {
    if (err.code !== 'ENOENT') {
      console.error(err);
    }
  })).filter(function (x) {
    return x;
  }); // filter any undefineds, those were invalid
}

var masterEICache = {};

function checkMasterCache(config, rtenv, dnv, packEI) {
  // ret obs of masterEI
  var masterEI = masterEICache[dnv];

  if (masterEI) {
    if (!masterEI.then) {
      // it is not a promise
      return _rxjs.Observable.of(masterEI);
    } // otherwise it was a promise


    return _rxjs.Observable.fromPromise(masterEI);
  } // otherwise not found


  var masterEIProm = findExistingMaster(config, rtenv, dnv, packEI);
  masterEICache[dnv] = masterEIProm; // optimize future requests so they don't need to hit promise

  masterEIProm.then(function (masterEI) {
    masterEICache[dnv] = masterEI; // eliminate promise overhead
  });
  return _rxjs.Observable.fromPromise(masterEIProm);
}

function determinePackLinkSrcDst(config, rtenv, destEIdn) {
  // ret obs of srcDstObj
  if (rtenv.cancelled) {
    return _rxjs.Observable.empty();
  }

  var dstEI = destEIdn.entryInfo,
      dnv = destEIdn.devNameVer;
  return checkMasterCache(config, rtenv, dnv, dstEI).takeWhile(function () {
    return !rtenv.cancelled;
  }).filter(function (masterEI) {
    return !isEISameInode(masterEI, dstEI);
  }).map(function (masterEI) {
    return {
      devNameVer: dnv,
      // device:nameVersion
      src: masterEI.fullParentDir,
      srcPackInode: masterEI.stat.ino,
      srcPackMTimeEpoch: masterEI.stat.mtime.getTime(),
      dst: dstEI.fullParentDir,
      dstPackInode: dstEI.stat.ino,
      dstPackMTimeEpoch: dstEI.stat.mtime.getTime()
    };
  });
}

function isEISameInode(firstEI, secondEI) {
  return firstEI.stat.dev === secondEI.stat.dev && firstEI.stat.ino === secondEI.stat.ino;
} // prepare for this to be async


function getExistingPackRefs(config, rtenv, dnv) {
  // returns observable to arrPackRefs
  // check rtenv.existingPackRefs[dnv] for ref tuples
  var masterPackRefs = _ramda["default"].pathOr([], [dnv], rtenv.existingPackRefs); // array of [modDir, packInode, packMTimeEpoch] packRef tuples


  return _rxjs.Observable.of(masterPackRefs);
}

function findExistingMaster(config, rtenv, dnv, ei) {
  // returns promise resolving to masterEI

  /*
     we will be checking through the rtenv.existingPackRefs[dnv] packRefs
     to see if any are still valid. Resolve with the first one that is
     still valid, also returning the remaining packRefs. Not all of the
     packRefs will have been checked, just enough to find one valid one.
     A new array of refs will be updated in rtenv.updatedPackRefs
     which will omit any found to be invalid.
     Resolves with masterEI or uses ei provided
   */
  return getExistingPackRefs(config, rtenv, dnv).mergeMap(function (masterPackRefs) {
    if (!masterPackRefs.length) {
      // no valid found, set to empty []
      rtenv.updatedPackRefs[dnv] = [buildPackRef(ei.fullParentDir, ei.stat.ino, ei.stat.mtime.getTime())];
      return _rxjs.Observable.of(ei);
    } // otherwise we have packrefs check them


    return _rxjs.Observable.from(masterPackRefs).mergeMap(function (packRef) {
      return verifyPackRef(dnv, packRef, true);
    }, 1 // one at a time since only need first
    ).first(function (masterEI) {
      return masterEI;
    }, // exists
    function (masterEI, idx) {
      return [masterEI, idx];
    }, false).map(function (masterEI_idx) {
      if (!masterEI_idx) {
        // no valid found, set to empty []
        rtenv.updatedPackRefs[dnv] = [buildPackRef(ei.fullParentDir, ei.stat.ino, ei.stat.mtime.getTime())];
        return ei;
      }

      var idx = masterEI_idx[1]; // wasn't first one so needs slicing

      rtenv.updatedPackRefs[dnv] = masterPackRefs.slice(idx);
      var masterEI = masterEI_idx[0];
      return masterEI;
    });
  }).toPromise(_bluebird["default"]);
}