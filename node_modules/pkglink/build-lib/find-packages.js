"use strict";

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.function.name");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = findPackages;

var _fsExtraPromise = _interopRequireDefault(require("fs-extra-promise"));

var _path = _interopRequireDefault(require("path"));

var _ramda = _interopRequireDefault(require("ramda"));

var _readdirp = _interopRequireDefault(require("readdirp"));

var _rxjs = require("rxjs");

var _format = require("./util/format");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// unix or windows paths
var ENDS_NODE_MOD_RE = /[\\/]node_modules$/;
/*
   Special directory tree filter for finding node_module/X packages
   - no dirs starting with '.'
   - accept node_modules
   - if under ancestor of node_modules
   - allow if parent is node_modules (keep in node_modules/X tree)
   - otherwise allow (not yet found node_modules tree)
 */

function filterDirsNodeModPacks(ei) {
  var eiName = ei.name;

  if (eiName.charAt(0) === '.') {
    return false;
  } // no dot dirs


  if (eiName === 'node_modules') {
    return true;
  } // node_modules


  var eiFullParentDir = ei.fullParentDir;

  if (eiFullParentDir.indexOf('node_modules') !== -1) {
    // under node_modules
    // only if grand parent is node_modules will we continue down
    return _path["default"].basename(eiFullParentDir) === 'node_modules';
  }

  return true; // not in node_modules yet, so keep walking
}

function findPackages(config, rtenv, rootDirs, logUpdate) {
  // ret obs of eiDN
  return _rxjs.Observable.from(rootDirs) // find all package.json files
  .mergeMap(function (startDir) {
    var readdirpOptions = {
      root: startDir,
      entryType: 'files',
      lstat: true,
      // want actual files not symlinked
      fileFilter: ['package.json'],
      directoryFilter: filterDirsNodeModPacks
    };

    if (config.treeDepth) {
      readdirpOptions.depth = config.treeDepth;
    }

    var fstream = (0, _readdirp["default"])(readdirpOptions);
    rtenv.cancelled$.subscribe(function () {
      return fstream.destroy();
    }); // stop reading

    return _rxjs.Observable.fromEvent(fstream, 'data').takeWhile(function () {
      return !rtenv.cancelled;
    }).takeUntil(_rxjs.Observable.fromEvent(fstream, 'close')).takeUntil(_rxjs.Observable.fromEvent(fstream, 'end'));
  }, config.concurrentOps) // only parents ending in node_modules
  .filter(function (ei) {
    return ENDS_NODE_MOD_RE.test(_path["default"].dirname(ei.fullParentDir));
  }) // get name and version from package.json
  .mergeMap(function (ei) {
    return _rxjs.Observable.from(_fsExtraPromise["default"].readJsonAsync(ei.fullPath, {
      "throws": false
    }));
  }, function (ei, pack) {
    return {
      // returns eiDN
      entryInfo: truncEI(ei),
      devNameVer: pack && pack.name && pack.version ? (0, _format.formatDevNameVersion)(ei.stat.dev, pack.name, pack.version) : null
    };
  }, config.concurrentOps).filter(function (obj) {
    return obj.devNameVer;
  }) // has name and version, not null
  ["do"](function (obj) {
    rtenv.packageCount += 1;
    rtenv.currentPackageDir = obj.entryInfo.fullParentDir;
  })["do"](function (obj) {
    logUpdate();
  });
}
/*
  Truncate entryInfo to just fullParentDir and stat to save memory
 */


function truncEI(ei) {
  return _ramda["default"].pick(['fullParentDir', 'stat'], ei);
}