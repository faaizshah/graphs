"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.genModuleLinks = genModuleLinks;
exports.handleModuleLinking = handleModuleLinking;
exports.determineLinks = determineLinks;

var _fsExtraPromise = _interopRequireDefault(require("fs-extra-promise"));

var _path = _interopRequireDefault(require("path"));

var _readdirp = _interopRequireDefault(require("readdirp"));

var _rxjs = require("rxjs");

var _packRef = require("./pack-ref");

var _linkFilter = _interopRequireDefault(require("./link-filter"));

var _log = require("./util/log");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/*
 Default hard link function which unlinks orig dst then creates link
 If failed to link (maybe fs doesn't support), recopy from src
 @return promise that resolves on success or rejects on failure
 */
function hardLink(src, dst) {
  return _fsExtraPromise["default"].unlinkAsync(dst).then(function () {
    return _fsExtraPromise["default"].linkAsync(src, dst);
  })["catch"](function (err) {
    _fsExtraPromise["default"].copyAsync(src, dst, {
      clobber: false,
      preserveTimestamps: true
    }).then(function () {
      console.error('INFO: recopied %s to %s to cleanup from link error which follows', src, dst);
    })["catch"](function ()
    /* err */
    {
      console.error('ERROR: was not able to restore %s after link error that follows, reinstall package', dst);
    });

    throw err; // rethrow original err
  });
}

function genModuleLinks(config, rtenv, lnkModSrcDst) {
  // returns observable
  return determineLinks(config, rtenv, lnkModSrcDst, true) // just output the ln commands
  ["do"](function (_ref) {
    var _ref2 = _slicedToArray(_ref, 3),
        src = _ref2[0],
        dst = _ref2[1],
        size = _ref2[2];

    rtenv.out("ln -f \"".concat(src, "\" \"").concat(dst, "\""));
  });
}

function handleModuleLinking(config, rtenv, lnkModSrcDst) {
  // returns observable
  return determineLinks(config, rtenv, lnkModSrcDst, true).mergeMap(function (s_d_sz) {
    return performLink(config, rtenv, s_d_sz);
  }, function (s_d_sz, ops) {
    return s_d_sz;
  }, config.concurrentOps);
}

function determineLinks(config, rtenv, lnkModSrcDst) {
  var updatePackRefs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // returns observable of s_d_sz [srcFullPath, dstFullPath, size]
  var logUpdate = (0, _log.createLogUpdate)(config, rtenv); // src is the master we link from, dst is the dst link

  var devNameVer = lnkModSrcDst.devNameVer; // device:nameVersion

  var srcRoot = lnkModSrcDst.src;
  var srcPackInode = lnkModSrcDst.srcPackInode;
  var srcPackMTimeEpoch = lnkModSrcDst.srcPackMTimeEpoch;
  var dstRoot = lnkModSrcDst.dst;
  var dstPackInode = lnkModSrcDst.dstPackInode;
  var dstPackMTimeEpoch = lnkModSrcDst.dstPackMTimeEpoch;

  if (updatePackRefs) {
    var packRefs = rtenv.updatedPackRefs[devNameVer] || [];

    if (!packRefs.length) {
      packRefs.push((0, _packRef.buildPackRef)(srcRoot, srcPackInode, srcPackMTimeEpoch));
    }

    packRefs = packRefs.filter(function (packRef) {
      return packRef[0] !== dstRoot;
    });

    if (packRefs.length < config.refSize) {
      packRefs.push((0, _packRef.buildPackRef)(dstRoot, dstPackInode, dstPackMTimeEpoch));
    }

    rtenv.updatedPackRefs[devNameVer] = packRefs;
  }

  var fstream = (0, _readdirp["default"])({
    root: lnkModSrcDst.src,
    entryType: 'files',
    lstat: true,
    // want actual files not symlinked
    fileFilter: ['!.*'],
    directoryFilter: ['!.*', '!node_modules']
  });
  fstream.once('end', function () {
    rtenv.completedPackages += 1;
    logUpdate();
  });
  rtenv.cancelled$.subscribe(function () {
    return fstream.destroy();
  }); // stop reading

  return _rxjs.Observable.fromEvent(fstream, 'data').takeWhile(function () {
    return !rtenv.cancelled;
  }).takeUntil(_rxjs.Observable.fromEvent(fstream, 'close')).takeUntil(_rxjs.Observable.fromEvent(fstream, 'end')) // combine with stat for dst
  .mergeMap(function (srcEI) {
    var dstPath = _path["default"].resolve(dstRoot, srcEI.path);

    return _rxjs.Observable.from(_fsExtraPromise["default"].statAsync(dstPath).then(function (stat) {
      return {
        fullPath: dstPath,
        stat: stat
      };
    })["catch"](function (err) {
      if (err.code !== 'ENOENT') {
        console.error(err);
      }

      return null;
    }));
  }, function (srcEI, dstEI) {
    return {
      srcEI: srcEI,
      dstEI: dstEI
    };
  }, config.concurrentOps).filter(function (x) {
    return (0, _linkFilter["default"])(config, dstPackInode, x);
  }).map(function (x) {
    return [// s_d_sz
    x.srcEI.fullPath, x.dstEI.fullPath, x.srcEI.stat.size];
  });
}

function performLink(config, rtenv, _ref3) {
  var _ref4 = _slicedToArray(_ref3, 3),
      src = _ref4[0],
      dst = _ref4[1],
      size = _ref4[2];

  // returns observable
  var link = rtenv.linkFn || hardLink; // use custom link if provided

  return _rxjs.Observable.fromPromise(link(src, dst)["catch"](function (err) {
    console.error("ERROR: failed to unlink/link src:".concat(src, " dst:").concat(dst), err);
    throw err;
  }));
}